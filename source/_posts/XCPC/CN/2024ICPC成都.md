---
title: 2024ICPC成都
date: 2025-09-15 09:50:14
mathjax: true
tags:
---

[gym](https://codeforces.com/gym/105486) | [榜单](https://board.xcpcio.com/icpc%2F49th%2Fchengdu?group=official)

这一场是 [@GUAIKATTO](https://codeforces.com/profile/GUAIKATTO) 和我一起在 9 月 12 日 VP 的，感谢大手子带我玩。

[![pVfZXY4.png](https://s21.ax1x.com/2025/09/15/pVfZXY4.png)](https://imgse.com/i/pVfZXY4)

感觉我其实没有帮上很多忙，比赛开始看到题目，我才发现之前我打过这一场了，我以为没打过。我还特意检查了两个 qoj 账号，在主页都没有显示我打过这场比赛，后来才发现，qoj 主页只会显示虚拟参加的比赛。

[![pVfZxp9.png](https://s21.ax1x.com/2025/09/15/pVfZxp9.png)](https://imgse.com/i/pVfZxp9)

这是我去年打的，在 ucup 打的，这个榜也传 cf 去了。其实影响也不大，去年只写了三个签到，而且还想了很久。。。而且补题一个都没补，谴责自己，这最后一个赛季，我要如何挣扎一下？

## A

> 啊啊啊，我自己写的话，可能要想好久 A，刚才弄了半小时没写对。有点不世人了，去年还写过一次，当时有队友跟我讨论，我记得一起讨论了还挺久。唉唉，题目这种东西，你看到一个题目，就会想起曾经和你一起讨论的人。

```cpp
#include<bits/stdc++.h>
using namespace std;
// created: 2025-09-15 10:23:52
void solve(){
    string s; cin >> s;
    int n = s.size();
    s = " " + s;
    if(s[1] != '>' || s[n] != '>' || s[n - 1] != '>' || s[n - 2] != '>'){
        cout << "No\n";
        return;
    }
    int r = -1;
    for(int i = n; i >= 1; i--){
        if(s[i] == '-'){
            r = i + 1;
            break;
        }
    }
    if(r == -1){cout << "No\n"; return;}
    vector<pair<int, int>> ans;
    for(int i = n; i >= r + 2; i--)
        ans.emplace_back(1, i);
    for(int i = 2; i < r; i++)
        if(s[i] == '>') ans.emplace_back(i, r + 2);
    cout << "Yes " << ans.size() << "\n";
    for(auto [x, y] : ans)
        cout << x << " " << y - x + 1 << "\n";
}
int main(){
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
    int t; cin >> t; while(t--)
    {solve();} return 0;
}
```

也贴一下去年的 code 吧。

```cpp
#include<bits/stdc++.h>
using namespace std;
using pii = pair<int,int>;
void solve() {
    string s;
    cin>>s;
    if(s[0]!='>') {
        cout<<"No\n";
        return;
    }
    int n=s.size();
    string t(n,'*');
    vector<pii>ans;
    int id=-1;
    // auto work=[&](int id,int l) {
    //     id--;
    //     t[id]='>';
    //     for(int i=1;i<l-3;i++) {
    //         t[id+i]='-';
    //     }
    //     for(int i=l-3;i<l;i++)
    //         t[id+i]='>';
    // };
    for(int i=n-1;i>=1;i--) {
        if(s[i]=='-') {
            if(n-i<=3) {
                //[i,n-1]
                cout<<"No\n";
                return;
            }
            id=i;
            break;
        }
    }
    if(id==-1) {
        cout<<"No\n";
        return;
    }
    //先把它后面的都变成>>>
    for(int i=n-1;i-2>id;i--)
        ans.emplace_back(1,i+1);
    for(int i=1;i<id;i++) {
        if(s[i]=='>')
            ans.emplace_back(i+1,id+3-i+1);
        //[i,id+3]
    }
    cout<<"Yes\n"<<ans.size()<<'\n';
    for(auto [i,l]:ans) {
        // work(i,l);
        cout<<i<<" "<<l<<'\n';
        // cerr<<t<<'\n';
    }
    // assert(t==s);
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int T;
    cin>>T;
    while(T--)
        solve();
    return 0;
}
```

## B

可以用 $O(n^3)$ 的 dp 解决，算出有 $x$ 个 a, $y$ 个 b， $z$ 个 c 的答案，然后前缀和一下。

```cpp
#include<bits/stdc++.h>
using namespace std;
// created: 2025-09-12 18:53:59
int dp[3][301][301], ndp[3][301][301], ans[301][301][301];
constexpr int mod = 1000000007;
void solve(){
    int n, q; cin >> n >> q;
    string s; cin >> s;
    s = " " + s;
    
    //dp a,x,y 表示当前字符是 a,用了x个a，y个b的方案数量
    // dp[0][0][0] = dp[1][0][0] = dp[2][0][0] = 1;
    int cnt = 0; // 已经填好的字符的数量
    if(s[1] == '?'){
        dp[0][1][0] = dp[1][0][1] = dp[2][0][0] = 1;
        cnt = 1;
    }else{
        dp[s[1] - 'a'][0][0] = 1;
    }
    for(int i = 2; i <= n; i++){
        // memset(ndp, 0, sizeof(ndp));
        if(s[i] != '?'){
            // 当前结尾
            int c = s[i] - 'a';
            for(int last = 0; last < 3; last++){
                if(last == c) continue;
                for(int x = 0; x <= cnt; x++){
                    for(int y = 0; y + x <= cnt; y++){
                        ndp[c][x][y] = (ndp[c][x][y] + dp[last][x][y]) % mod;
                    }
                }
            }
        }else{
            for(int now = 0; now < 3; now++){
                for(int last = 0; last < 3; last++){
                    if(now == last) continue;
                    // if(s[i - 1] != '?' && s[i - 1] - 'a' != last) continue;
                    for(int x = 0; x <= cnt; x++){
                        for(int y = 0; x + y <= cnt; y++){
                            if(now == 0)
                                ndp[0][x + 1][y] = (ndp[0][x + 1][y] + dp[last][x][y]) % mod;
                            else if(now == 1)
                                ndp[1][x][y + 1] = (ndp[1][x][y + 1] + dp[last][x][y]) % mod;
                            else
                                ndp[2][x][y] = (ndp[2][x][y] + dp[last][x][y]) % mod;
                        }
                    }
                }
            }
            ++cnt;
        }
        for(int now = 0; now < 3; now++){
            for(int x = 0; x <= cnt; x++){
                for(int y = 0; y + x <= cnt; y++){
                    dp[now][x][y] = ndp[now][x][y];
                    ndp[now][x][y] = 0;
                }
            }
        }
    }
    for(int c = 0; c < 3; c++){
        for(int x = 0; x <= cnt; x++){
            for(int y = 0; x + y <= cnt; y++){
                int z = cnt - x - y;
                ans[x][y][z] = (ans[x][y][z] + dp[c][x][y]) % mod;
                // if(dp[c][x][y]){
                //     cerr << format("dp : {}, [c,x,y] : [{}, {}, {}]\n", dp[c][x][y], c, x, y);
                // }
            }
        }
    }
    // 不对。。。
    for(int x = 1; x <= 300; x++)
    for(int y = 0; y <= 300; y++)
    for(int z = 0; z <= 300; z++)
        ans[x][y][z] = (ans[x][y][z] + ans[x - 1][y][z]) % mod;
    for(int y = 1; y <= 300; y++)
    for(int x = 0; x <= 300; x++)
    for(int z = 0; z <= 300; z++)
        ans[x][y][z] = (ans[x][y][z] + ans[x][y - 1][z]) % mod;
    for(int z = 1; z <= 300; z++)
    for(int x = 0; x <= 300; x++)
    for(int y = 0; y <= 300; y++)
        ans[x][y][z] = (ans[x][y][z] + ans[x][y][z - 1]) % mod;
    while(q--){
        int x, y, z;
        cin >> x >> y >> z;
        cout << ans[x][y][z] << "\n";
    }
}
int main(){
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
    // int t; cin >> t; while(t--)
    {solve();} return 0;
}
```

## I

> 队友写的，我自己VP的话，感觉不可能写出这题。

一个数组可以分成若干段递增子数组，我们找每个子数组最长的情况。则符合要求的 $k$，必须是每一段的长度的因子，除了最后一段。所以我们需要维护每一段的长度，求 gcd，输出因子个数。

要修改而且是 gcd，我知道的好像只能用线段树了。那么我们还需要知道的是，修改操作对于每段长度的影响，就是分类讨论增加或减小，和前后两个数字的相对关系的变化，以及是否是一段的末尾。

用 set 或 map 存一下，分类讨论一下就好了。以及需要特判 gcd 为 0 的情况，自然是数组递增的情况，答案为 $n$，记得多测要清空线段树。自己写还 WA 了几次，以后我注意如果要减去一些东西，能打括号就加一个。。。不然我可能就会算错加减法，之前也是犯过同样的错误。

```cpp
#include<bits/stdc++.h>
using namespace std;
// created: 2025-09-15 08:50:12
constexpr int N = 200005;
int val[N << 2];
array<int, N> divs;
void change(int p, int l, int r, int i, int x){
    if(l == r){
        val[p] = x;
        // cerr << l << " " << r << " " << x << '\n';
        return;
    }
    int mid = (l + r) >> 1;
    if(i <= mid) change(p << 1, l, mid, i, x);
    else change(p << 1 | 1, mid + 1, r, i, x);
    val[p] = gcd(val[p << 1], val[p << 1 | 1]);
}
void solve(){
    int n, q; cin >> n >> q;
    vector<int> a(n + 1);
    for(int i = 1; i <= n; i++) cin >> a[i];
    set<int> st{0};
    for(int i = 1; i + 1 <= n; i++){
        if(a[i] > a[i + 1]){
            change(1, 1, n, i, i - *st.rbegin());
            st.insert(i);
        }
    }
    cout << (val[1] ? divs[val[1]] : n) << "\n";
    st.insert(n);
    while(q--){
        int p, v; cin >> p >> v;
        if(v > a[p]){
            if(p < n && v > a[p + 1]){
                if(!st.contains(p)){
                    auto it = st.upper_bound(p);
                    if(*it != n)
                        change(1, 1, n, *it, *it - p);
                    change(1, 1, n, p, p - *prev(it));
                    st.insert(p);
                }
            }
            if(p > 1 && v >= a[p - 1] && st.contains(p - 1)){
                st.erase(p - 1);
                change(1, 1, n, p - 1, 0);
                auto it = st.lower_bound(p);
                if(*it != n)
                    change(1, 1, n, *it, *it - *prev(it));
            }
        }else if(v < a[p]){
            if(p < n && v <= a[p + 1]){
                if(st.contains(p)){
                    change(1, 1, n, p, 0);
                    st.erase(p);
                    auto it = st.upper_bound(p);
                    if(*it != n)
                        change(1, 1, n, *it, *it - *prev(it));
                }
            }
            if(p > 1 && v < a[p - 1] && !st.contains(p - 1)){
                auto it = st.upper_bound(p - 1);
                change(1, 1, n, p - 1, p - 1 - *prev(it));
                if(*it != n)
                    change(1, 1, n, *it, *it - (p - 1));
                st.insert(p - 1);
            }
        }
        a[p] = v;
        cout << (val[1] ? divs[val[1]] : n) << "\n";
        // return;
    }
    for(auto x : st)
        change(1, 1, n, x, 0);
}
int main(){
    // freopen("1.in", "r", stdin);
    for(int i = 1; i < N; i++){
        for(int j = i; j < N; j += i)
            divs[j]++;
    }
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
    int t; cin >> t; while(t--)
    {solve();} return 0;
}
```

## L

```cpp
// Date: 2025-09-12 16:37:39
// Author: wuyi
// 
// Problem: L. Recover Statistics
// Contest: Codeforces - 2024 ICPC Asia Chengdu Regional Contest (The 3rd Universal Cup. Stage 15: Chengdu)
// URL: https://codeforces.com/gym/105486/problem/L
// Memory Limit: 1024 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
using LL = long long;
void solve(){
    int a, b, c; cin >> a >> b >> c;
    cout << "100\n";
    for(int i = 1; i <= 50; i++) cout << a << " ";
    for(int i = 1; i <= 45; i++) cout << b << " ";
    for(int i = 1; i <= 4; i++) cout << c << " ";
    cout << c + 1 << "\n";
}
int main(){
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
    // int t; cin >> t; while(t--)
    {solve();} return 0;
}
```

