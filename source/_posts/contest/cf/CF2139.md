---
title: Codeforces Round 1048 (Div. 2)
date: 2025-09-18 08:12:05
categories: codeforces
mathjax: true
---

## E

给一颗以 1 为根节点的树，每个节点都有一个权值 0 或 1，定义树的美丽值等于所有的从根节点到叶子节点的路径的权值组成字符串的最长公共子序列的长度。

要求分配恰好 $k$ 个 1 和 $n - k$ 个 0 作为点权，输出可以达到的最大的美丽值。

### solution

首先最大的答案一定不会超过深度最小的叶子节点的深度 $d$。

恰好所有叶子节点的深度相同时，可以看作是背包问题，我们可以确定哪些值可以达到。如果 $dp_k = 1$，那么答案就为 $d$，否则答案一定是 $d - 1$。但前哪个值的数量 $\ge c_i$，就把当前的 $c_i$ 设为哪个值。由于 $c_i \le c_{i+1}$，深度小于 $d$ 的节点，每个深度的值都可以相同。

```cpp
// Date: 2025-09-18 08:31:41
// Author: wuyi
// 
// Problem: E1. Maple and Tree Beauty (Easy Version)
// Contest: Codeforces - Codeforces Round 1048 (Div. 2)
// URL: https://codeforces.com/contest/2139/problem/E1
// Memory Limit: 1024 MB
// Time Limit: 3000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
using LL = long long;
void solve(){
    int n, k; cin >> n >> k;
    vector<int> dep(n + 1), fa(n + 1), cnt(n + 1), deg(n + 1);
    cnt[0] = 1;
    for(int i = 2; i <= n; i++){
    	cin >> fa[i];
    	dep[i] = dep[fa[i]] + 1;
    	cnt[dep[i]]++;
    	deg[fa[i]]++;
    }
    int mxdep = INT_MAX;
    for(int i = 1; i <= n; i++)
    	if(!deg[i]) mxdep = min(mxdep, dep[i]);
	vector<int> dp(n + 1);
	dp[0] = 1;
	int sum = 0;
    for(int i = 0; i <= mxdep; i++){
    	for(int j = sum; j >= 0; j--){
    		dp[j + cnt[i]] |= dp[j];
    	}
    	sum += cnt[i];
    }
    for(int i = 0; i <= sum; i++){
    	if(dp[i]){
    		if(i <= k && sum - i <= n - k){
    			cout << mxdep + 1 << "\n";
    			return;
    		}
    	}
    }
    cout << mxdep << "\n";
}
int main(){
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
    int t; cin >> t; while(t--)
    {solve();} return 0;
}
```